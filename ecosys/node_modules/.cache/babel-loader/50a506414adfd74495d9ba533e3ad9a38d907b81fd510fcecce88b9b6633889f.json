{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { LatLngBounds, toLatLngBounds as latLngBounds, Layer, Browser, Util, Point, Bounds } from 'leaflet';\nexport var FeatureGrid = Layer.extend({\n  // @section\n  // @aka GridLayer options\n  options: {\n    // @option cellSize: Number|Point = 256\n    // Width and height of cells in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\n    cellSize: 512,\n    // @option updateWhenIdle: Boolean = (depends)\n    // Load new cells only when panning ends.\n    // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\n    // `false` otherwise in order to display new cells _during_ panning, since it is easy to pan outside the\n    // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\n    updateWhenIdle: Browser.mobile,\n    // @option updateInterval: Number = 150\n    // Cells will not update more than once every `updateInterval` milliseconds when panning.\n    updateInterval: 150,\n    // @option noWrap: Boolean = false\n    // Whether the layer is wrapped around the antimeridian. If `true`, the\n    // GridLayer will only be displayed once at low zoom levels. Has no\n    // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\n    // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\n    // cells outside the CRS limits.\n    noWrap: false,\n    // @option keepBuffer: Number = 1.5\n    // When panning the map, keep this many rows and columns of cells before unloading them.\n    keepBuffer: 1.5\n  },\n  initialize: function (options) {\n    Util.setOptions(this, options);\n  },\n  onAdd: function (map) {\n    this._cells = {};\n    this._activeCells = {};\n    this._resetView();\n    this._update();\n  },\n  onRemove: function (map) {\n    this._removeAllCells();\n    this._cellZoom = undefined;\n  },\n  // @method isLoading: Boolean\n  // Returns `true` if any cell in the grid layer has not finished loading.\n  isLoading: function () {\n    return this._loading;\n  },\n  // @method redraw: this\n  // Causes the layer to clear all the cells and request them again.\n  redraw: function () {\n    if (this._map) {\n      this._removeAllCells();\n      this._update();\n    }\n    return this;\n  },\n  getEvents: function () {\n    var events = {\n      viewprereset: this._invalidateAll,\n      viewreset: this._resetView,\n      zoom: this._resetView,\n      moveend: this._onMoveEnd\n    };\n    if (!this.options.updateWhenIdle) {\n      // update cells on move, but not more often than once per given interval\n      if (!this._onMove) {\n        this._onMove = Util.throttle(this._onMoveEnd, this.options.updateInterval, this);\n      }\n      events.move = this._onMove;\n    }\n    return events;\n  },\n  // @section Extension methods\n  // Layers extending `GridLayer` shall reimplement the following method.\n  // @method createCell(coords: Object, done?: Function): HTMLElement\n  // Called only internally, must be overridden by classes extending `GridLayer`.\n  // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\n  // is specified, it must be called when the cell has finished loading and drawing.\n  createCell: function () {\n    return document.createElement('div');\n  },\n  removeCell: function () {},\n  reuseCell: function () {},\n  cellLeave: function () {},\n  cellEnter: function () {},\n  // @section\n  // @method getCellSize: Point\n  // Normalizes the [cellSize option](#gridlayer-cellsize) into a point. Used by the `createCell()` method.\n  getCellSize: function () {\n    var s = this.options.cellSize;\n    return s instanceof Point ? s : new Point(s, s);\n  },\n  _pruneCells: function () {\n    if (!this._map) {\n      return;\n    }\n    var key, cell;\n    for (key in this._cells) {\n      cell = this._cells[key];\n      cell.retain = cell.current;\n    }\n    for (key in this._cells) {\n      cell = this._cells[key];\n      if (cell.current && !cell.active) {\n        var coords = cell.coords;\n        if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n          this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n        }\n      }\n    }\n    for (key in this._cells) {\n      if (!this._cells[key].retain) {\n        this._removeCell(key);\n      }\n    }\n  },\n  _removeAllCells: function () {\n    for (var key in this._cells) {\n      this._removeCell(key);\n    }\n  },\n  _invalidateAll: function () {\n    this._removeAllCells();\n    this._cellZoom = undefined;\n  },\n  _retainParent: function (x, y, z, minZoom) {\n    var x2 = Math.floor(x / 2);\n    var y2 = Math.floor(y / 2);\n    var z2 = z - 1;\n    var coords2 = new Point(+x2, +y2);\n    coords2.z = +z2;\n    var key = this._cellCoordsToKey(coords2);\n    var cell = this._cells[key];\n    if (cell && cell.active) {\n      cell.retain = true;\n      return true;\n    } else if (cell && cell.loaded) {\n      cell.retain = true;\n    }\n    if (z2 > minZoom) {\n      return this._retainParent(x2, y2, z2, minZoom);\n    }\n    return false;\n  },\n  _retainChildren: function (x, y, z, maxZoom) {\n    for (var i = 2 * x; i < 2 * x + 2; i++) {\n      for (var j = 2 * y; j < 2 * y + 2; j++) {\n        var coords = new Point(i, j);\n        coords.z = z + 1;\n        var key = this._cellCoordsToKey(coords);\n        var cell = this._cells[key];\n        if (cell && cell.active) {\n          cell.retain = true;\n          continue;\n        } else if (cell && cell.loaded) {\n          cell.retain = true;\n        }\n        if (z + 1 < maxZoom) {\n          this._retainChildren(i, j, z + 1, maxZoom);\n        }\n      }\n    }\n  },\n  _resetView: function (e) {\n    var animating = e && (e.pinch || e.flyTo);\n    if (animating) {\n      return;\n    }\n    this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n  },\n  _setView: function (center, zoom, noPrune, noUpdate) {\n    var cellZoom = Math.round(zoom);\n    if (!noUpdate) {\n      this._cellZoom = cellZoom;\n      if (this._abortLoading) {\n        this._abortLoading();\n      }\n      this._resetGrid();\n      if (cellZoom !== undefined) {\n        this._update(center);\n      }\n      if (!noPrune) {\n        this._pruneCells();\n      }\n\n      // Flag to prevent _updateOpacity from pruning cells during\n      // a zoom anim or a pinch gesture\n      this._noPrune = !!noPrune;\n    }\n  },\n  _resetGrid: function () {\n    var map = this._map;\n    var crs = map.options.crs;\n    var cellSize = this._cellSize = this.getCellSize();\n    var cellZoom = this._cellZoom;\n    var bounds = this._map.getPixelWorldBounds(this._cellZoom);\n    if (bounds) {\n      this._globalCellRange = this._pxBoundsToCellRange(bounds);\n    }\n    this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], cellZoom).x / cellSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], cellZoom).x / cellSize.y)];\n    this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], cellZoom).y / cellSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], cellZoom).y / cellSize.y)];\n  },\n  _onMoveEnd: function (e) {\n    var animating = e && (e.pinch || e.flyTo);\n    if (animating || !this._map || this._map._animatingZoom) {\n      return;\n    }\n    this._update();\n  },\n  _getCelldPixelBounds: function (center) {\n    var map = this._map;\n    var mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom();\n    var scale = map.getZoomScale(mapZoom, this._cellZoom);\n    var pixelCenter = map.project(center, this._cellZoom).floor();\n    var halfSize = map.getSize().divideBy(scale * 2);\n    return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n  },\n  // Private method to load cells in the grid's active zoom level according to map bounds\n  _update: function (center) {\n    var map = this._map;\n    if (!map) {\n      return;\n    }\n    var zoom = Math.round(map.getZoom());\n    if (center === undefined) {\n      center = map.getCenter();\n    }\n    var pixelBounds = this._getCelldPixelBounds(center);\n    var cellRange = this._pxBoundsToCellRange(pixelBounds);\n    var cellCenter = cellRange.getCenter();\n    var queue = [];\n    var margin = this.options.keepBuffer;\n    var noPruneRange = new Bounds(cellRange.getBottomLeft().subtract([margin, -margin]), cellRange.getTopRight().add([margin, -margin]));\n\n    // Sanity check: panic if the cell range contains Infinity somewhere.\n    if (!(isFinite(cellRange.min.x) && isFinite(cellRange.min.y) && isFinite(cellRange.max.x) && isFinite(cellRange.max.y))) {\n      throw new Error('Attempted to load an infinite number of cells');\n    }\n    for (var key in this._cells) {\n      var c = this._cells[key].coords;\n      if (c.z !== this._cellZoom || !noPruneRange.contains(new Point(c.x, c.y))) {\n        this._cells[key].current = false;\n      }\n    }\n\n    // _update just loads more cells. If the cell zoom level differs too much\n    // from the map's, let _setView reset levels and prune old cells.\n    if (Math.abs(zoom - this._cellZoom) > 1) {\n      this._setView(center, zoom);\n      return;\n    }\n\n    // create a queue of coordinates to load cells from\n    for (var j = cellRange.min.y; j <= cellRange.max.y; j++) {\n      for (var i = cellRange.min.x; i <= cellRange.max.x; i++) {\n        var coords = new Point(i, j);\n        coords.z = this._cellZoom;\n        if (!this._isValidCell(coords)) {\n          continue;\n        }\n        var cell = this._cells[this._cellCoordsToKey(coords)];\n        if (cell) {\n          cell.current = true;\n        } else {\n          queue.push(coords);\n        }\n      }\n    }\n\n    // sort cell queue to load cells in order of their distance to center\n    queue.sort(function (a, b) {\n      return a.distanceTo(cellCenter) - b.distanceTo(cellCenter);\n    });\n    if (queue.length !== 0) {\n      // if it's the first batch of cells to load\n      if (!this._loading) {\n        this._loading = true;\n      }\n      for (i = 0; i < queue.length; i++) {\n        var _key = this._cellCoordsToKey(queue[i]);\n        var _coords = this._keyToCellCoords(_key);\n        if (this._activeCells[_coords]) {\n          this._reuseCell(queue[i]);\n        } else {\n          this._createCell(queue[i]);\n        }\n      }\n    }\n  },\n  _isValidCell: function (coords) {\n    var crs = this._map.options.crs;\n    if (!crs.infinite) {\n      // don't load cell if it's out of bounds and not wrapped\n      var bounds = this._globalCellRange;\n      if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {\n        return false;\n      }\n    }\n    if (!this.options.bounds) {\n      return true;\n    }\n\n    // don't load cell if it doesn't intersect the bounds in options\n    var cellBounds = this._cellCoordsToBounds(coords);\n    return latLngBounds(this.options.bounds).overlaps(cellBounds);\n  },\n  _keyToBounds: function (key) {\n    return this._cellCoordsToBounds(this._keyToCellCoords(key));\n  },\n  _cellCoordsToNwSe: function (coords) {\n    var map = this._map;\n    var cellSize = this.getCellSize();\n    var nwPoint = coords.scaleBy(cellSize);\n    var sePoint = nwPoint.add(cellSize);\n    var nw = map.unproject(nwPoint, coords.z);\n    var se = map.unproject(sePoint, coords.z);\n    return [nw, se];\n  },\n  // converts cell coordinates to its geographical bounds\n  _cellCoordsToBounds: function (coords) {\n    var bp = this._cellCoordsToNwSe(coords);\n    var bounds = new LatLngBounds(bp[0], bp[1]);\n    if (!this.options.noWrap) {\n      bounds = this._map.wrapLatLngBounds(bounds);\n    }\n    return bounds;\n  },\n  // converts cell coordinates to key for the cell cache\n  _cellCoordsToKey: function (coords) {\n    return coords.x + ':' + coords.y + ':' + coords.z;\n  },\n  // converts cell cache key to coordinates\n  _keyToCellCoords: function (key) {\n    var k = key.split(':');\n    var coords = new Point(+k[0], +k[1]);\n    coords.z = +k[2];\n    return coords;\n  },\n  _removeCell: function (key) {\n    var cell = this._cells[key];\n    if (!cell) {\n      return;\n    }\n    var coords = this._keyToCellCoords(key);\n    var wrappedCoords = this._wrapCoords(coords);\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\n    cell.current = false;\n    delete this._cells[key];\n    this._activeCells[key] = cell;\n    this.cellLeave(cellBounds, wrappedCoords, key);\n    this.fire('cellleave', {\n      key: key,\n      coords: wrappedCoords,\n      bounds: cellBounds\n    });\n  },\n  _reuseCell: function (coords) {\n    var key = this._cellCoordsToKey(coords);\n\n    // save cell in cache\n    this._cells[key] = this._activeCells[key];\n    this._cells[key].current = true;\n    var wrappedCoords = this._wrapCoords(coords);\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\n    this.cellEnter(cellBounds, wrappedCoords, key);\n    this.fire('cellenter', {\n      key: key,\n      coords: wrappedCoords,\n      bounds: cellBounds\n    });\n  },\n  _createCell: function (coords) {\n    var key = this._cellCoordsToKey(coords);\n    var wrappedCoords = this._wrapCoords(coords);\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\n    this.createCell(cellBounds, wrappedCoords, key);\n    this.fire('cellcreate', {\n      key: key,\n      coords: wrappedCoords,\n      bounds: cellBounds\n    });\n\n    // save cell in cache\n    this._cells[key] = {\n      coords: coords,\n      current: true\n    };\n    Util.requestAnimFrame(this._pruneCells, this);\n  },\n  _cellReady: function (coords, err, cell) {\n    var key = this._cellCoordsToKey(coords);\n    cell = this._cells[key];\n    if (!cell) {\n      return;\n    }\n    cell.loaded = +new Date();\n    cell.active = true;\n  },\n  _getCellPos: function (coords) {\n    return coords.scaleBy(this.getCellSize());\n  },\n  _wrapCoords: function (coords) {\n    var newCoords = new Point(this._wrapX ? Util.wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? Util.wrapNum(coords.y, this._wrapY) : coords.y);\n    newCoords.z = coords.z;\n    return newCoords;\n  },\n  _pxBoundsToCellRange: function (bounds) {\n    var cellSize = this.getCellSize();\n    return new Bounds(bounds.min.unscaleBy(cellSize).floor(), bounds.max.unscaleBy(cellSize).ceil().subtract([1, 1]));\n  }\n});","map":{"version":3,"names":["LatLngBounds","toLatLngBounds","latLngBounds","Layer","Browser","Util","Point","Bounds","FeatureGrid","extend","options","cellSize","updateWhenIdle","mobile","updateInterval","noWrap","keepBuffer","initialize","setOptions","onAdd","map","_cells","_activeCells","_resetView","_update","onRemove","_removeAllCells","_cellZoom","undefined","isLoading","_loading","redraw","_map","getEvents","events","viewprereset","_invalidateAll","viewreset","zoom","moveend","_onMoveEnd","_onMove","throttle","move","createCell","document","createElement","removeCell","reuseCell","cellLeave","cellEnter","getCellSize","s","_pruneCells","key","cell","retain","current","active","coords","_retainParent","x","y","z","_retainChildren","_removeCell","minZoom","x2","Math","floor","y2","z2","coords2","_cellCoordsToKey","loaded","maxZoom","i","j","e","animating","pinch","flyTo","_setView","getCenter","getZoom","center","noPrune","noUpdate","cellZoom","round","_abortLoading","_resetGrid","_noPrune","crs","_cellSize","bounds","getPixelWorldBounds","_globalCellRange","_pxBoundsToCellRange","_wrapX","wrapLng","project","ceil","_wrapY","wrapLat","_animatingZoom","_getCelldPixelBounds","mapZoom","max","_animateToZoom","scale","getZoomScale","pixelCenter","halfSize","getSize","divideBy","subtract","add","pixelBounds","cellRange","cellCenter","queue","margin","noPruneRange","getBottomLeft","getTopRight","isFinite","min","Error","c","contains","abs","_isValidCell","push","sort","a","b","distanceTo","length","_key","_coords","_keyToCellCoords","_reuseCell","_createCell","infinite","cellBounds","_cellCoordsToBounds","overlaps","_keyToBounds","_cellCoordsToNwSe","nwPoint","scaleBy","sePoint","nw","unproject","se","bp","wrapLatLngBounds","k","split","wrappedCoords","_wrapCoords","fire","requestAnimFrame","_cellReady","err","Date","_getCellPos","newCoords","wrapNum","unscaleBy"],"sources":["E:/Working/IP_proj/EcosystemCivi/ecosys/node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureGrid.js"],"sourcesContent":["import {\r\n  LatLngBounds,\r\n  toLatLngBounds as latLngBounds,\r\n  Layer,\r\n  Browser,\r\n  Util,\r\n  Point,\r\n  Bounds\r\n} from 'leaflet';\r\n\r\nexport var FeatureGrid = Layer.extend({\r\n  // @section\r\n  // @aka GridLayer options\r\n  options: {\r\n    // @option cellSize: Number|Point = 256\r\n    // Width and height of cells in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\r\n    cellSize: 512,\r\n\r\n    // @option updateWhenIdle: Boolean = (depends)\r\n    // Load new cells only when panning ends.\r\n    // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\r\n    // `false` otherwise in order to display new cells _during_ panning, since it is easy to pan outside the\r\n    // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\r\n    updateWhenIdle: Browser.mobile,\r\n\r\n    // @option updateInterval: Number = 150\r\n    // Cells will not update more than once every `updateInterval` milliseconds when panning.\r\n    updateInterval: 150,\r\n\r\n    // @option noWrap: Boolean = false\r\n    // Whether the layer is wrapped around the antimeridian. If `true`, the\r\n    // GridLayer will only be displayed once at low zoom levels. Has no\r\n    // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\r\n    // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\r\n    // cells outside the CRS limits.\r\n    noWrap: false,\r\n\r\n    // @option keepBuffer: Number = 1.5\r\n    // When panning the map, keep this many rows and columns of cells before unloading them.\r\n    keepBuffer: 1.5\r\n  },\r\n\r\n  initialize: function (options) {\r\n    Util.setOptions(this, options);\r\n  },\r\n\r\n  onAdd: function (map) {\r\n    this._cells = {};\r\n    this._activeCells = {};\r\n    this._resetView();\r\n    this._update();\r\n  },\r\n\r\n  onRemove: function (map) {\r\n    this._removeAllCells();\r\n    this._cellZoom = undefined;\r\n  },\r\n\r\n  // @method isLoading: Boolean\r\n  // Returns `true` if any cell in the grid layer has not finished loading.\r\n  isLoading: function () {\r\n    return this._loading;\r\n  },\r\n\r\n  // @method redraw: this\r\n  // Causes the layer to clear all the cells and request them again.\r\n  redraw: function () {\r\n    if (this._map) {\r\n      this._removeAllCells();\r\n      this._update();\r\n    }\r\n    return this;\r\n  },\r\n\r\n  getEvents: function () {\r\n    var events = {\r\n      viewprereset: this._invalidateAll,\r\n      viewreset: this._resetView,\r\n      zoom: this._resetView,\r\n      moveend: this._onMoveEnd\r\n    };\r\n\r\n    if (!this.options.updateWhenIdle) {\r\n      // update cells on move, but not more often than once per given interval\r\n      if (!this._onMove) {\r\n        this._onMove = Util.throttle(\r\n          this._onMoveEnd,\r\n          this.options.updateInterval,\r\n          this\r\n        );\r\n      }\r\n\r\n      events.move = this._onMove;\r\n    }\r\n\r\n    return events;\r\n  },\r\n\r\n  // @section Extension methods\r\n  // Layers extending `GridLayer` shall reimplement the following method.\r\n  // @method createCell(coords: Object, done?: Function): HTMLElement\r\n  // Called only internally, must be overridden by classes extending `GridLayer`.\r\n  // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\r\n  // is specified, it must be called when the cell has finished loading and drawing.\r\n  createCell: function () {\r\n    return document.createElement('div');\r\n  },\r\n\r\n  removeCell: function () {\r\n\r\n  },\r\n\r\n  reuseCell: function () {\r\n\r\n  },\r\n\r\n  cellLeave: function () {\r\n\r\n  },\r\n\r\n  cellEnter: function () {\r\n\r\n  },\r\n  // @section\r\n  // @method getCellSize: Point\r\n  // Normalizes the [cellSize option](#gridlayer-cellsize) into a point. Used by the `createCell()` method.\r\n  getCellSize: function () {\r\n    var s = this.options.cellSize;\r\n    return s instanceof Point ? s : new Point(s, s);\r\n  },\r\n\r\n  _pruneCells: function () {\r\n    if (!this._map) {\r\n      return;\r\n    }\r\n\r\n    var key, cell;\r\n\r\n    for (key in this._cells) {\r\n      cell = this._cells[key];\r\n      cell.retain = cell.current;\r\n    }\r\n\r\n    for (key in this._cells) {\r\n      cell = this._cells[key];\r\n      if (cell.current && !cell.active) {\r\n        var coords = cell.coords;\r\n        if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\r\n          this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (key in this._cells) {\r\n      if (!this._cells[key].retain) {\r\n        this._removeCell(key);\r\n      }\r\n    }\r\n  },\r\n\r\n  _removeAllCells: function () {\r\n    for (var key in this._cells) {\r\n      this._removeCell(key);\r\n    }\r\n  },\r\n\r\n  _invalidateAll: function () {\r\n    this._removeAllCells();\r\n\r\n    this._cellZoom = undefined;\r\n  },\r\n\r\n  _retainParent: function (x, y, z, minZoom) {\r\n    var x2 = Math.floor(x / 2);\r\n    var y2 = Math.floor(y / 2);\r\n    var z2 = z - 1;\r\n    var coords2 = new Point(+x2, +y2);\r\n    coords2.z = +z2;\r\n\r\n    var key = this._cellCoordsToKey(coords2);\r\n    var cell = this._cells[key];\r\n\r\n    if (cell && cell.active) {\r\n      cell.retain = true;\r\n      return true;\r\n    } else if (cell && cell.loaded) {\r\n      cell.retain = true;\r\n    }\r\n\r\n    if (z2 > minZoom) {\r\n      return this._retainParent(x2, y2, z2, minZoom);\r\n    }\r\n\r\n    return false;\r\n  },\r\n\r\n  _retainChildren: function (x, y, z, maxZoom) {\r\n    for (var i = 2 * x; i < 2 * x + 2; i++) {\r\n      for (var j = 2 * y; j < 2 * y + 2; j++) {\r\n        var coords = new Point(i, j);\r\n        coords.z = z + 1;\r\n\r\n        var key = this._cellCoordsToKey(coords);\r\n        var cell = this._cells[key];\r\n\r\n        if (cell && cell.active) {\r\n          cell.retain = true;\r\n          continue;\r\n        } else if (cell && cell.loaded) {\r\n          cell.retain = true;\r\n        }\r\n\r\n        if (z + 1 < maxZoom) {\r\n          this._retainChildren(i, j, z + 1, maxZoom);\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  _resetView: function (e) {\r\n    var animating = e && (e.pinch || e.flyTo);\r\n\r\n    if (animating) {\r\n      return;\r\n    }\r\n\r\n    this._setView(\r\n      this._map.getCenter(),\r\n      this._map.getZoom(),\r\n      animating,\r\n      animating\r\n    );\r\n  },\r\n\r\n  _setView: function (center, zoom, noPrune, noUpdate) {\r\n    var cellZoom = Math.round(zoom);\r\n\r\n    if (!noUpdate) {\r\n      this._cellZoom = cellZoom;\r\n\r\n      if (this._abortLoading) {\r\n        this._abortLoading();\r\n      }\r\n\r\n      this._resetGrid();\r\n\r\n      if (cellZoom !== undefined) {\r\n        this._update(center);\r\n      }\r\n\r\n      if (!noPrune) {\r\n        this._pruneCells();\r\n      }\r\n\r\n      // Flag to prevent _updateOpacity from pruning cells during\r\n      // a zoom anim or a pinch gesture\r\n      this._noPrune = !!noPrune;\r\n    }\r\n  },\r\n\r\n  _resetGrid: function () {\r\n    var map = this._map;\r\n    var crs = map.options.crs;\r\n    var cellSize = (this._cellSize = this.getCellSize());\r\n    var cellZoom = this._cellZoom;\r\n\r\n    var bounds = this._map.getPixelWorldBounds(this._cellZoom);\r\n    if (bounds) {\r\n      this._globalCellRange = this._pxBoundsToCellRange(bounds);\r\n    }\r\n\r\n    this._wrapX = crs.wrapLng &&\r\n      !this.options.noWrap && [\r\n      Math.floor(map.project([0, crs.wrapLng[0]], cellZoom).x / cellSize.x),\r\n      Math.ceil(map.project([0, crs.wrapLng[1]], cellZoom).x / cellSize.y)\r\n    ];\r\n    this._wrapY = crs.wrapLat &&\r\n      !this.options.noWrap && [\r\n      Math.floor(map.project([crs.wrapLat[0], 0], cellZoom).y / cellSize.x),\r\n      Math.ceil(map.project([crs.wrapLat[1], 0], cellZoom).y / cellSize.y)\r\n    ];\r\n  },\r\n\r\n  _onMoveEnd: function (e) {\r\n    var animating = e && (e.pinch || e.flyTo);\r\n\r\n    if (animating || !this._map || this._map._animatingZoom) {\r\n      return;\r\n    }\r\n\r\n    this._update();\r\n  },\r\n\r\n  _getCelldPixelBounds: function (center) {\r\n    var map = this._map;\r\n    var mapZoom = map._animatingZoom\r\n      ? Math.max(map._animateToZoom, map.getZoom())\r\n      : map.getZoom();\r\n    var scale = map.getZoomScale(mapZoom, this._cellZoom);\r\n    var pixelCenter = map.project(center, this._cellZoom).floor();\r\n    var halfSize = map.getSize().divideBy(scale * 2);\r\n\r\n    return new Bounds(\r\n      pixelCenter.subtract(halfSize),\r\n      pixelCenter.add(halfSize)\r\n    );\r\n  },\r\n\r\n  // Private method to load cells in the grid's active zoom level according to map bounds\r\n  _update: function (center) {\r\n    var map = this._map;\r\n    if (!map) {\r\n      return;\r\n    }\r\n    var zoom = Math.round(map.getZoom());\r\n\r\n    if (center === undefined) {\r\n      center = map.getCenter();\r\n    }\r\n\r\n    var pixelBounds = this._getCelldPixelBounds(center);\r\n    var cellRange = this._pxBoundsToCellRange(pixelBounds);\r\n    var cellCenter = cellRange.getCenter();\r\n    var queue = [];\r\n    var margin = this.options.keepBuffer;\r\n    var noPruneRange = new Bounds(\r\n      cellRange.getBottomLeft().subtract([margin, -margin]),\r\n      cellRange.getTopRight().add([margin, -margin])\r\n    );\r\n\r\n    // Sanity check: panic if the cell range contains Infinity somewhere.\r\n    if (\r\n      !(\r\n        isFinite(cellRange.min.x) &&\r\n        isFinite(cellRange.min.y) &&\r\n        isFinite(cellRange.max.x) &&\r\n        isFinite(cellRange.max.y)\r\n      )\r\n    ) {\r\n      throw new Error('Attempted to load an infinite number of cells');\r\n    }\r\n\r\n    for (var key in this._cells) {\r\n      var c = this._cells[key].coords;\r\n      if (\r\n        c.z !== this._cellZoom ||\r\n        !noPruneRange.contains(new Point(c.x, c.y))\r\n      ) {\r\n        this._cells[key].current = false;\r\n      }\r\n    }\r\n\r\n    // _update just loads more cells. If the cell zoom level differs too much\r\n    // from the map's, let _setView reset levels and prune old cells.\r\n    if (Math.abs(zoom - this._cellZoom) > 1) {\r\n      this._setView(center, zoom);\r\n      return;\r\n    }\r\n\r\n    // create a queue of coordinates to load cells from\r\n    for (var j = cellRange.min.y; j <= cellRange.max.y; j++) {\r\n      for (var i = cellRange.min.x; i <= cellRange.max.x; i++) {\r\n        var coords = new Point(i, j);\r\n        coords.z = this._cellZoom;\r\n\r\n        if (!this._isValidCell(coords)) {\r\n          continue;\r\n        }\r\n\r\n        var cell = this._cells[this._cellCoordsToKey(coords)];\r\n        if (cell) {\r\n          cell.current = true;\r\n        } else {\r\n          queue.push(coords);\r\n        }\r\n      }\r\n    }\r\n\r\n    // sort cell queue to load cells in order of their distance to center\r\n    queue.sort(function (a, b) {\r\n      return a.distanceTo(cellCenter) - b.distanceTo(cellCenter);\r\n    });\r\n\r\n    if (queue.length !== 0) {\r\n      // if it's the first batch of cells to load\r\n      if (!this._loading) {\r\n        this._loading = true;\r\n      }\r\n\r\n      for (i = 0; i < queue.length; i++) {\r\n        var _key = this._cellCoordsToKey(queue[i]);\r\n        var _coords = this._keyToCellCoords(_key);\r\n        if (this._activeCells[_coords]) {\r\n          this._reuseCell(queue[i]);\r\n        } else {\r\n          this._createCell(queue[i]);\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  _isValidCell: function (coords) {\r\n    var crs = this._map.options.crs;\r\n\r\n    if (!crs.infinite) {\r\n      // don't load cell if it's out of bounds and not wrapped\r\n      var bounds = this._globalCellRange;\r\n      if (\r\n        (!crs.wrapLng &&\r\n          (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||\r\n        (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))\r\n      ) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    if (!this.options.bounds) {\r\n      return true;\r\n    }\r\n\r\n    // don't load cell if it doesn't intersect the bounds in options\r\n    var cellBounds = this._cellCoordsToBounds(coords);\r\n    return latLngBounds(this.options.bounds).overlaps(cellBounds);\r\n  },\r\n\r\n  _keyToBounds: function (key) {\r\n    return this._cellCoordsToBounds(this._keyToCellCoords(key));\r\n  },\r\n\r\n  _cellCoordsToNwSe: function (coords) {\r\n    var map = this._map;\r\n    var cellSize = this.getCellSize();\r\n    var nwPoint = coords.scaleBy(cellSize);\r\n    var sePoint = nwPoint.add(cellSize);\r\n    var nw = map.unproject(nwPoint, coords.z);\r\n    var se = map.unproject(sePoint, coords.z);\r\n\r\n    return [nw, se];\r\n  },\r\n\r\n  // converts cell coordinates to its geographical bounds\r\n  _cellCoordsToBounds: function (coords) {\r\n    var bp = this._cellCoordsToNwSe(coords);\r\n    var bounds = new LatLngBounds(bp[0], bp[1]);\r\n\r\n    if (!this.options.noWrap) {\r\n      bounds = this._map.wrapLatLngBounds(bounds);\r\n    }\r\n    return bounds;\r\n  },\r\n  // converts cell coordinates to key for the cell cache\r\n  _cellCoordsToKey: function (coords) {\r\n    return coords.x + ':' + coords.y + ':' + coords.z;\r\n  },\r\n\r\n  // converts cell cache key to coordinates\r\n  _keyToCellCoords: function (key) {\r\n    var k = key.split(':');\r\n    var coords = new Point(+k[0], +k[1]);\r\n\r\n    coords.z = +k[2];\r\n    return coords;\r\n  },\r\n\r\n  _removeCell: function (key) {\r\n    var cell = this._cells[key];\r\n\r\n    if (!cell) {\r\n      return;\r\n    }\r\n\r\n    var coords = this._keyToCellCoords(key);\r\n    var wrappedCoords = this._wrapCoords(coords);\r\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\r\n\r\n    cell.current = false;\r\n\r\n    delete this._cells[key];\r\n    this._activeCells[key] = cell;\r\n\r\n    this.cellLeave(cellBounds, wrappedCoords, key);\r\n\r\n    this.fire('cellleave', {\r\n      key: key,\r\n      coords: wrappedCoords,\r\n      bounds: cellBounds\r\n    });\r\n  },\r\n\r\n  _reuseCell: function (coords) {\r\n    var key = this._cellCoordsToKey(coords);\r\n\r\n    // save cell in cache\r\n    this._cells[key] = this._activeCells[key];\r\n    this._cells[key].current = true;\r\n\r\n    var wrappedCoords = this._wrapCoords(coords);\r\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\r\n\r\n    this.cellEnter(cellBounds, wrappedCoords, key);\r\n\r\n    this.fire('cellenter', {\r\n      key: key,\r\n      coords: wrappedCoords,\r\n      bounds: cellBounds\r\n    });\r\n  },\r\n\r\n  _createCell: function (coords) {\r\n    var key = this._cellCoordsToKey(coords);\r\n\r\n    var wrappedCoords = this._wrapCoords(coords);\r\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\r\n\r\n    this.createCell(cellBounds, wrappedCoords, key);\r\n\r\n    this.fire('cellcreate', {\r\n      key: key,\r\n      coords: wrappedCoords,\r\n      bounds: cellBounds\r\n    });\r\n\r\n    // save cell in cache\r\n    this._cells[key] = {\r\n      coords: coords,\r\n      current: true\r\n    };\r\n\r\n    Util.requestAnimFrame(this._pruneCells, this);\r\n  },\r\n\r\n  _cellReady: function (coords, err, cell) {\r\n    var key = this._cellCoordsToKey(coords);\r\n\r\n    cell = this._cells[key];\r\n\r\n    if (!cell) {\r\n      return;\r\n    }\r\n\r\n    cell.loaded = +new Date();\r\n\r\n    cell.active = true;\r\n  },\r\n\r\n  _getCellPos: function (coords) {\r\n    return coords.scaleBy(this.getCellSize());\r\n  },\r\n\r\n  _wrapCoords: function (coords) {\r\n    var newCoords = new Point(\r\n      this._wrapX ? Util.wrapNum(coords.x, this._wrapX) : coords.x,\r\n      this._wrapY ? Util.wrapNum(coords.y, this._wrapY) : coords.y\r\n    );\r\n    newCoords.z = coords.z;\r\n    return newCoords;\r\n  },\r\n\r\n  _pxBoundsToCellRange: function (bounds) {\r\n    var cellSize = this.getCellSize();\r\n    return new Bounds(\r\n      bounds.min.unscaleBy(cellSize).floor(),\r\n      bounds.max.unscaleBy(cellSize).ceil().subtract([1, 1])\r\n    );\r\n  }\r\n});\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}